---
title: "plot demonstration"
author: "Thijs Janzen"
date: "2023-01-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Plotting ancestral states 

Here, I want to give you a short (and minimal) demonstration of how to plot
your ancestral states alongside your tree.
Let us assume we have a simple tree, with almost trivial traits:

```{r starting_conditions}
set.seed(5)
focal_tree <- ape::rphylo(n = 4, birth = 1, death = 0)
traits <- c(0, 1, 1, 0)

plot(focal_tree)
```

A typical likelihood calculation would look like (assuming 2 observed and 2 
hidden traits):

```{r simple likelihood}
params <- secsse::id_paramPos(c(0, 1), 2)
params[[1]][] <- c(0.2, 0.2, 0.1, 0.1)
params[[2]][] <- 0.0
params[[3]][, ] <- 0.1
diag(params[[3]]) <- NA


ll <- secsse::secsse_loglik(parameter = params,
                             phy = focal_tree,
                             traits = traits,
                             num_concealed_states = 2,
                             see_ancestral_states = TRUE,
                             sampling_fraction = c(1, 1))
ll
```

If we want to visualize the change in trait probabilities across the tree, we
can use the function 'plot_state_exact'. To use this function, we need to provide
a helper function that can translate the posterior probabilities into a single
probability of interest. For instance, for 2 observed and 2 hidden traits,
we observe the following states reconstructed along the nodes:
```{r states}
ll$states
```

Here, the first four rows indicate the tip states, whilst the later three rows
indicate the states at the internal nodes (with the last row indicating the root,
in this case). The columns indicate the four extinction and four speciation rates,
following the order in params[[1]] and params[[2]]. Thus, we have for both, rates
0A, 1A, 0B and 1B. If we are interested in the posterior probability of trait 0,
we have to provide a helper function that sums the probabilities of 0A and 0B, e.g.:
```{r helper function}
helper_function <- function(x) {
  return(sum(x[c(5, 7)]) / sum(x)) # normalized by total sum, just in case.
}
```

We can now use this to plot this probability across the tree. There are two
options for plotting: using the evaluations along the branches as used by the
integration method, or evaluating the branch values at a specific number of intervals. 
Using the explicit evaluations is more precies, but might be memory heavy. Usually,
using 10-100 evaluations per branch provides a very accurate approximation:

```{r exact}
require(tidyverse)
secsse::plot_state_exact(parameters = params,
                 focal_tree = focal_tree,
                 traits = traits,
                 num_concealed_states = 2,
                 sampling_fraction = c(1, 1),
                 prob_func = helper_function)

secsse::plot_state_exact(parameters = params,
                 focal_tree = focal_tree,
                 traits = traits,
                 num_concealed_states = 2,
                 sampling_fraction = c(1, 1),
                 steps = 10,
                 prob_func = helper_function)

secsse::plot_state_exact(parameters = params,
                 focal_tree = focal_tree,
                 traits = traits,
                 num_concealed_states = 2,
                 sampling_fraction = c(1, 1),
                 steps = 100,
                 prob_func = helper_function)
```
